<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ ‚Äî 3D MVP</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π 3D –ú–∞—Ä–∏–∫ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–∂, –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –∫—Ä—É—Ç–∏—Ç—å, –≥–ª–∞–¥–∏—Ç—å –∏ —Ç—ã–∫–∞—Ç—å." />
  <meta name="theme-color" content="#151826" />

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #3b5fff 0%, #151826 40%, #05060b 100%);
      color: #fff;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      touch-action: none;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    #ui {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
      padding: 0 16px;
    }
    #title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-shadow: 0 4px 18px rgba(0,0,0,0.65);
    }
    #subtitle {
      margin-top: 4px;
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 11px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
      z-index: 10;
      backdrop-filter: blur(12px);
      max-width: 90vw;
      justify-content: center;
    }
    #hints span {
      opacity: 0.9;
      display: inline-flex;
      gap: 4px;
      align-items: center;
      white-space: nowrap;
    }
    #speech {
      position: fixed;
      top: 78px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 18px;
      min-width: 120px;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      max-width: 90vw;
    }
    #error-msg {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #05060b;
      color: #fff;
      z-index: 100;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }
    /* –ú—É—Ä—á–æ–º–µ—Ç—Ä */
    #mood-pill {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 10;
      backdrop-filter: blur(10px);
      max-width: 90vw;
      white-space: nowrap;
    }
    #mood-emoji {
      font-size: 16px;
    }
    @media (max-width: 600px) {
      #title { font-size: 22px; }
      #subtitle { font-size: 12px; }
      #speech { font-size: 16px; }
      #mood-pill { font-size: 11px; bottom: 68px; }
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <div id="title">–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ üßç‚Äç‚ôÇÔ∏è</div>
  <div id="subtitle">–ü–æ–≥–ª–∞–¥—å –º–µ–Ω—è ‚Äî —è –∑–∞–º—É—Ä—á—É. –¢—ã–∫–Ω–∏ –≤ –º–µ–Ω—è ‚Äî —è –≤–æ–∑–º<strong>—É</strong>—â—É—Å—å!</div>
</div>

<div id="speech"></div>

<!-- –ú—É—Ä—á–æ–º–µ—Ç—Ä -->
<div id="mood-pill">
  <span id="mood-emoji">üôÇ</span>
  <span id="mood-text">–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: 0</span>
</div>

<div id="hints">
  <span>üñ±Ô∏è –õ–ö–ú + –º—ã—à—å ‚Äî –∫—Ä—É—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</span>
  <span>üñ±Ô∏è –ö–æ–ª—ë—Å–∏–∫–æ ‚Äî –∑—É–º</span>
  <span>ü§ö –í–µ–¥–∏ –º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî –≥–ª–∞–¥—å</span>
  <span>üëÜ –ö–ª–∏–∫/—Ç–∞–ø –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî —Ä—É–≥–∞–µ—Ç—Å—è</span>
</div>

<div id="error-msg">
  <div>
    <div style="font-size:22px;margin-bottom:10px;">–£–ø—Å‚Ä¶ –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ üßØ</div>
    <div>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å 3D-—Å—Ü–µ–Ω—É. –ü–æ–ø—Ä–æ–±—É–π –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ.</div>
  </div>
</div>

<!-- importmap -->
<script type="importmap">
{
  "imports": {
    "three": "./three.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { FBXLoader } from './FBXLoader.js';

  const errorMsg = document.getElementById('error-msg');
  const speech = document.getElementById("speech");
  const moodEmojiEl = document.getElementById("mood-emoji");
  const moodTextEl = document.getElementById("mood-text");

  // –§—Ä–∞–∑—ã
  const petPhrases = [
    "–º—Ä—Ä—Ä‚Ä¶ üíú",
    "–æ –¥–∞‚Ä¶ –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Å—è üòå",
    "—Ç–∞–∫-—Ç–æ –ª—É—á—à–µ",
    "—è –≤—Å–µ–≥–¥–∞ –∑–Ω–∞–ª, —á—Ç–æ —Ç—ã –¥–æ–±—Ä—ã–π",
    "–µ—â—ë —á—É—Ç—å-—á—É—Ç—å‚Ä¶"
  ];
  const angryPhrases = [
    "!!!###!!!???!!!",
    "@#$%!!!",
    "—Ç—ã —á—ë –¥–µ–ª–∞–µ—à—å?!",
    "–Ω—É –∑–∞ —á—Ç–æ?!!",
    "—ç–π! –∞–∫–∫—É—Ä–∞—Ç–Ω–µ–µ!"
  ];
  const kneelPhrases = [
    "–ª–∞–¥–Ω–æ, –ª–∞–¥–Ω–æ‚Ä¶ —è —Å–¥–∞—é—Å—å üò¢",
    "—Ç–æ–ª—å–∫–æ –Ω–µ –±–µ–π –±–æ–ª—å—à–µ‚Ä¶",
    "–ø—Ä–æ—Å—Ç–∏, –¥–∞–≤–∞–π –º–∏—Ä üòî"
  ];

  // –ú—É—Ä—á–æ–º–µ—Ç—Ä
  let mood = 0; // -100..100
  const MOOD_MIN = -100;
  const MOOD_MAX = 100;

  function clampMood() {
    if (mood < MOOD_MIN) mood = MOOD_MIN;
    if (mood > MOOD_MAX) mood = MOOD_MAX;
  }

  function updateMoodUI() {
    clampMood();
    let emoji = "üôÇ";
    if (mood > 40) emoji = "üòä";
    else if (mood < 0) emoji = "üò†";
    moodEmojiEl.textContent = emoji;
    moodTextEl.textContent = `–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: ${mood}`;
  }

  updateMoodUI();

  function showSpeech(text, ms = 1000) {
    clearTimeout(showSpeech._timeout);
    speech.textContent = text;
    speech.style.display = "block";
    showSpeech._timeout = setTimeout(() => {
      speech.style.display = "none";
    }, ms);
  }

  try {
    initHappyMarik();
  } catch (e) {
    console.error(e);
    errorMsg.style.display = 'flex';
  }

  function initHappyMarik() {
    const container = document.getElementById("canvas-container");

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x05060b, 1);
    container.appendChild(renderer.domElement);

    // –ë–∞–∑–æ–≤—ã–π –∫—É—Ä—Å–æ—Ä
    renderer.domElement.style.cursor = 'grab';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060b, 6, 18);

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );

    const target = new THREE.Vector3(0, 1.2, 0);
    let camRadius = 5;
    let camYaw = 0.4;
    let camPitch = 0.9;

    function updateCamera() {
      const x = camRadius * Math.sin(camPitch) * Math.sin(camYaw);
      const y = camRadius * Math.cos(camPitch);
      const z = camRadius * Math.sin(camPitch) * Math.cos(camYaw);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }
    updateCamera();

    const hemiLight = new THREE.HemisphereLight(0xf5f7ff, 0x080814, 1.25);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(4, 8, 4);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 20;
    dirLight.shadow.camera.left = -7;
    dirLight.shadow.camera.right = 7;
    dirLight.shadow.camera.top = 7;
    dirLight.shadow.camera.bottom = -7;
    scene.add(dirLight);

    const floorGeom = new THREE.CircleGeometry(4, 64);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x181c30,
      roughness: 0.75,
      metalness: 0.05
    });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const glowGeom = new THREE.CircleGeometry(1.6, 40);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x5f9dff,
      transparent: true,
      opacity: 0.45
    });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    glow.rotation.x = -Math.PI / 2;
    glow.position.y = 0.01;
    scene.add(glow);

    const marik = new THREE.Group();
    marik.position.y = 0;
    scene.add(marik);

    const loader = new FBXLoader();
    let mixer = null;
    let idleAction = null;
    let fallAction = null;
    let kneelAction = null;
    let isKneeling = false;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π idle FBX
    loader.load(
      'marik_idle.fbx',
      (fbx) => {
        const s = 0.01;
        fbx.scale.set(s, s, s);
        fbx.position.set(0, 0, 0);

        fbx.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        marik.add(fbx);

        if (fbx.animations && fbx.animations.length > 0) {
          mixer = new THREE.AnimationMixer(fbx);
          idleAction = mixer.clipAction(fbx.animations[0]);
          idleAction.play();
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–∞–¥–µ–Ω–∏–µ
        loader.load(
          'marik_fall.fbx',
          (fallFbx) => {
            if (fallFbx.animations && fallFbx.animations.length > 0 && mixer) {
              const fallClip = fallFbx.animations[0];
              fallAction = mixer.clipAction(fallClip);
              fallAction.loop = THREE.LoopOnce;
              fallAction.clampWhenFinished = true;
            }
          },
          undefined,
          () => {}
        );

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–ª–µ–Ω–∏
        loader.load(
          'marik_kneel.fbx',
          (kneelFbx) => {
            if (kneelFbx.animations && kneelFbx.animations.length > 0 && mixer) {
              const kneelClip = kneelFbx.animations[0];
              kneelAction = mixer.clipAction(kneelClip);
              kneelAction.loop = THREE.LoopOnce;
              kneelAction.clampWhenFinished = true;
            }
          },
          undefined,
          () => {}
        );

      },
      undefined,
      (err) => {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ FBX:', err);
        errorMsg.style.display = 'flex';
      }
    );

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isHoveringMarik = false;
    let lastPetTime = 0;

    function updateMouse(evt) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function checkHover() {
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      isHoveringMarik = hits.length > 0;

      if (isHoveringMarik && !isDragging) {
        renderer.domElement.style.cursor = 'pointer';
      } else if (!isDragging) {
        renderer.domElement.style.cursor = 'grab';
      }
    }

    // –ü–æ–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
    window.addEventListener("pointermove", (e) => {
      updateMouse(e);
      checkHover();
      if (isHoveringMarik) {
        const now = performance.now();
        if (now - lastPetTime > 350) {
          lastPetTime = now;

          mood += 10;
          clampMood();
          updateMoodUI();

          const phrase = petPhrases[Math.floor(Math.random() * petPhrases.length)];
          showSpeech(phrase, 800);

          // –ï—Å–ª–∏ –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ–¥–Ω—è–ª–æ—Å—å ‚Äî –ø–æ—Ç–∏—Ö–æ–Ω—å–∫—É –≤—Å—Ç–∞—ë—Ç
          if (isKneeling && mood > -10 && kneelAction && idleAction && mixer) {
            kneelAction.fadeOut(0.3);
            idleAction.reset().fadeIn(0.3).play();
            isKneeling = false;
          }
        }
      }
    });

    function triggerKneel() {
      if (!kneelAction || !idleAction || !mixer || isKneeling) return;

      isKneeling = true;

      // —Å—Ç–æ–ø–∞—Ç—å –ø–∞–¥–µ–Ω–∏–µ, –µ—Å–ª–∏ –∏–¥—ë—Ç
      if (fallAction) fallAction.stop();

      idleAction.fadeOut(0.2);
      kneelAction.reset().fadeIn(0.25).play();

      const phrase = kneelPhrases[Math.floor(Math.random() * kneelPhrases.length)];
      showSpeech(phrase, 1500);
    }

    // –£–¥–∞—Ä—ã
    window.addEventListener("pointerdown", (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      if (hits.length > 0) {
        // –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ -25
        mood -= 25;
        clampMood();
        updateMoodUI();

        // –µ—Å–ª–∏ —Å–∏–ª—å–Ω–æ –∑–∞–≥–Ω–∞–ª ‚Äî –Ω–∞ –∫–æ–ª–µ–Ω–∏
        if (mood <= -60) {
          triggerKneel();
        } else {
          // –æ–±—ã—á–Ω–∞—è –∑–ª–∞—è —Ä–µ–∞–∫—Ü–∏—è —Å –ø–∞–¥–µ–Ω–∏–µ–º
          const phrase = angryPhrases[Math.floor(Math.random() * angryPhrases.length)];
          showSpeech(phrase, 1300);

          if (!isKneeling && fallAction && idleAction && mixer) {
            idleAction.fadeOut(0.15);
            fallAction.reset().fadeIn(0.1).play();

            setTimeout(() => {
              fallAction.fadeOut(0.25);
              idleAction.reset().fadeIn(0.25).play();
            }, 900);
          }
        }

        // –î–æ–ø. —Ç—Ä—è—Å–∫–∞ (—á–µ–º —Ö—É–∂–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ ‚Äî —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ)
        const start = performance.now();
        const initialPosX = marik.position.x;
        const badFactor = 1 + Math.max(0, -mood / 100);
        function shake(timestamp) {
          const t = timestamp - start;
          const power = Math.max(0, 1 - t / 300);
          marik.position.x = initialPosX + Math.sin(t * 0.06) * 0.07 * power * badFactor;
          if (t < 300) requestAnimationFrame(shake);
          else marik.position.x = initialPosX;
        }
        requestAnimationFrame(shake);
      }
    });

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π + –∫—É—Ä—Å–æ—Ä
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      renderer.domElement.style.cursor = 'grabbing';
    });

    window.addEventListener("pointerup", () => {
      isDragging = false;
      renderer.domElement.style.cursor = isHoveringMarik ? 'pointer' : 'grab';
    });

    window.addEventListener("pointerleave", () => {
      isDragging = false;
      renderer.domElement.style.cursor = isHoveringMarik ? 'pointer' : 'grab';
    });

    window.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const ROT_SPEED = 0.005;
      camYaw -= dx * ROT_SPEED;
      camPitch -= dy * ROT_SPEED;

      const minPitch = 0.4;
      const maxPitch = Math.PI - 0.4;
      camPitch = Math.max(minPitch, Math.min(maxPitch, camPitch));

      updateCamera();
    });

    window.addEventListener("wheel", (e) => {
      const ZOOM_SPEED = 0.0015;
      camRadius += e.deltaY * ZOOM_SPEED * camRadius;
      camRadius = Math.max(3.2, Math.min(7, camRadius));
      updateCamera();
    }, { passive: true });

    const clock = new THREE.Clock();
    let elapsed = 0;

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      elapsed += delta;

      if (mixer) mixer.update(delta);

      // –ê–º–ø–ª–∏—Ç—É–¥–∞ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è (–µ—Å–ª–∏ –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö ‚Äî –º–µ–Ω—å—à–µ)
      const moodNorm = (mood + 100) / 200; // 0..1
      const baseFactor = isKneeling ? 0.3 : 1.0;
      const bobAmp = baseFactor * (0.03 + 0.04 * moodNorm);
      const swayAmp = baseFactor * (0.12 + 0.08 * moodNorm);

      marik.position.y = Math.sin(elapsed * 2) * bobAmp;
      marik.rotation.y = Math.sin(elapsed * 0.5) * swayAmp;

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  }
</script>
</body>
</html>
