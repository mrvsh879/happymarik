<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ ‚Äî 3D MVP</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π 3D –ú–∞—Ä–∏–∫ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–∂, –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –∫—Ä—É—Ç–∏—Ç—å, –≥–ª–∞–¥–∏—Ç—å –∏ —Ç—ã–∫–∞—Ç—å." />
  <meta name="theme-color" content="#151826" />

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #3b5fff 0%, #151826 40%, #05060b 100%);
      color: #fff;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      touch-action: none;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    #ui {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
      padding: 0 16px;
    }
    #title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-shadow: 0 4px 18px rgba(0,0,0,0.65);
    }
    #subtitle {
      margin-top: 4px;
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 11px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
      z-index: 10;
      backdrop-filter: blur(12px);
      max-width: 90vw;
      justify-content: center;
    }
    #hints span {
      opacity: 0.9;
      display: inline-flex;
      gap: 4px;
      align-items: center;
      white-space: nowrap;
    }
    #speech {
      position: fixed;
      top: 78px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 18px;
      min-width: 120px;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      max-width: 90vw;
    }
    #error-msg {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #05060b;
      color: #fff;
      z-index: 100;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }
    @media (max-width: 600px) {
      #title { font-size: 22px; }
      #subtitle { font-size: 12px; }
      #speech { font-size: 16px; }
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <div id="title">–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ üßç‚Äç‚ôÇÔ∏è</div>
  <div id="subtitle">–ü–æ–≥–ª–∞–¥—å –º–µ–Ω—è ‚Äî —è –∑–∞–º—É—Ä—á—É. –¢—ã–∫–Ω–∏ –≤ –º–µ–Ω—è ‚Äî —è –≤–æ–∑–º<strong>—É</strong>—â—É—Å—å!</div>
</div>

<div id="speech"></div>

<div id="hints">
  <span>üñ±Ô∏è –õ–ö–ú + –º—ã—à—å ‚Äî –∫—Ä—É—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</span>
  <span>üñ±Ô∏è –ö–æ–ª—ë—Å–∏–∫–æ ‚Äî –∑—É–º</span>
  <span>ü§ö –í–µ–¥–∏ –º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî –≥–ª–∞–¥—å</span>
  <span>üëÜ –ö–ª–∏–∫/—Ç–∞–ø –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî —Ä—É–≥–∞–µ—Ç—Å—è</span>
</div>

<div id="error-msg">
  <div>
    <div style="font-size:22px;margin-bottom:10px;">–£–ø—Å‚Ä¶ –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ üßØ</div>
    <div>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å 3D-—Å—Ü–µ–Ω—É. –ü–æ–ø—Ä–æ–±—É–π –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ.</div>
  </div>
</div>

<script type="module">
  import * as THREE from './three.module.js';
  import { FBXLoader } from './FBXLoader.js';

  const errorMsg = document.getElementById('error-msg');

  try {
    initHappyMarik();
  } catch (e) {
    console.error(e);
    errorMsg.style.display = 'flex';
  }

  function initHappyMarik() {
    const container = document.getElementById("canvas-container");

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x05060b, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060b, 6, 18);

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );

    const target = new THREE.Vector3(0, 1.2, 0);
    let camRadius = 5;
    let camYaw = 0.4;
    let camPitch = 0.9;

    function updateCamera() {
      const x = camRadius * Math.sin(camPitch) * Math.sin(camYaw);
      const y = camRadius * Math.cos(camPitch);
      const z = camRadius * Math.sin(camPitch) * Math.cos(camYaw);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }
    updateCamera();

    const hemiLight = new THREE.HemisphereLight(0xf5f7ff, 0x080814, 1.25);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(4, 8, 4);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 20;
    dirLight.shadow.camera.left = -7;
    dirLight.shadow.camera.right = 7;
    dirLight.shadow.camera.top = 7;
    dirLight.shadow.camera.bottom = -7;
    scene.add(dirLight);

    const floorGeom = new THREE.CircleGeometry(4, 64);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x181c30,
      roughness: 0.75,
      metalness: 0.05
    });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const glowGeom = new THREE.CircleGeometry(1.6, 40);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x5f9dff,
      transparent: true,
      opacity: 0.45
    });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    glow.rotation.x = -Math.PI / 2;
    glow.position.y = 0.01;
    scene.add(glow);

    const marik = new THREE.Group();
    marik.position.y = 0;
    scene.add(marik);

    const loader = new FBXLoader();
    let mixer = null;

    loader.load(
      'marik_idle.fbx',
      (fbx) => {
        const s = 0.01;
        fbx.scale.set(s, s, s);
        fbx.position.set(0, 0, 0);

        fbx.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        marik.add(fbx);

        if (fbx.animations && fbx.animations.length > 0) {
          mixer = new THREE.AnimationMixer(fbx);
          const action = mixer.clipAction(fbx.animations[0]);
          action.play();
        }
      },
      undefined,
      (err) => {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ FBX:', err);
        errorMsg.style.display = 'flex';
      }
    );

    const speech = document.getElementById("speech");
    let speechTimeout = null;

    function showSpeech(text, ms = 1000) {
      clearTimeout(speechTimeout);
      speech.textContent = text;
      speech.style.display = "block";
      speechTimeout = setTimeout(() => {
        speech.style.display = "none";
      }, ms);
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isHoveringMarik = false;
    let isAngry = false;
    let angryTimer = 0;
    let lastPetTime = 0;

    function updateMouse(evt) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function checkHover() {
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      isHoveringMarik = hits.length > 0;
    }

    window.addEventListener("pointermove", (e) => {
      updateMouse(e);
      checkHover();
      if (isHoveringMarik) {
        const now = performance.now();
        if (now - lastPetTime > 350) {
          lastPetTime = now;
          showSpeech("–º—Ä—Ä—Ä—Ä‚Ä¶ üíú", 700);
        }
      }
    });

    window.addEventListener("pointerdown", (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      if (hits.length > 0) {
        isAngry = true;
        angryTimer = performance.now();
        showSpeech("!!!###!!!???!!!", 1300);

        const start = performance.now();
        const initialPosX = marik.position.x;
        function shake(timestamp) {
          const t = timestamp - start;
          const power = Math.max(0, 1 - t / 300);
          marik.position.x = initialPosX + Math.sin(t * 0.06) * 0.07 * power;
          if (t < 300) requestAnimationFrame(shake);
          else marik.position.x = initialPosX;
        }
        requestAnimationFrame(shake);
      }
    });

    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener("pointerup", () => {
      isDragging = false;
    });

    window.addEventListener("pointerleave", () => {
      isDragging = false;
    });

    window.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const ROT_SPEED = 0.005;
      camYaw -= dx * ROT_SPEED;
      camPitch -= dy * ROT_SPEED;

      const minPitch = 0.4;
      const maxPitch = Math.PI - 0.4;
      camPitch = Math.max(minPitch, Math.min(maxPitch, camPitch));

      updateCamera();
    });

    window.addEventListener("wheel", (e) => {
      const ZOOM_SPEED = 0.0015;
      camRadius += e.deltaY * ZOOM_SPEED * camRadius;
      camRadius = Math.max(3.2, Math.min(7, camRadius));
      updateCamera();
    }, { passive: true });

    const clock = new THREE.Clock();
    let elapsed = 0;

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      elapsed += delta;

      if (mixer) mixer.update(delta);

      marik.position.y = Math.sin(elapsed * 2) * 0.05;
      marik.rotation.y = Math.sin(elapsed * 0.5) * 0.15;

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  }
</script>
</body>
</html>
