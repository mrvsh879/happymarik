<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ ‚Äî 3D MVP</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #3b5fff 0%, #151826 40%, #05060b 100%);
      color: #fff;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    #ui {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }
    #title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-shadow: 0 4px 18px rgba(0,0,0,0.65);
    }
    #subtitle {
      margin-top: 4px;
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 12px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 10;
      backdrop-filter: blur(12px);
    }
    #hints span {
      opacity: 0.9;
      display: inline-flex;
      gap: 4px;
      align-items: center;
    }
    #speech {
      position: fixed;
      top: 78px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 18px;
      min-width: 120px;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <div id="title">–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ üêæ</div>
  <div id="subtitle">–ü–æ–≥–ª–∞–¥—å –º–µ–Ω—è ‚Äî —è –∑–∞–º—É—Ä—á—É. –¢—ã–∫–Ω–∏ –≤ –º–µ–Ω—è ‚Äî —è –≤–æ–∑–º<strong>—É</strong>—â—É—Å—å!</div>
</div>

<div id="speech"></div>

<div id="hints">
  <span>üñ±Ô∏è –õ–ö–ú + –º—ã—à—å ‚Äî –∫—Ä—É—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</span>
  <span>üñ±Ô∏è –ö–æ–ª—ë—Å–∏–∫–æ ‚Äî –∑—É–º</span>
  <span>ü§ö –í–µ–¥–∏ –º—ã—à–∫–æ–π –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî –≥–ª–∞–¥—å</span>
  <span>üëÜ –ö–ª–∏–∫ –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî —Ä—É–≥–∞–µ—Ç—Å—è</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<script>
  // ===== –ë–ê–ó–û–í–ê–Ø –°–¶–ï–ù–ê =====
  const container = document.getElementById("canvas-container");

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x05060b, 6, 18);

  const camera = new THREE.PerspectiveCamera(
    55,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );

  // –ö–∞–º–µ—Ä–∞ –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ (0,1,0) —á–µ—Ä–µ–∑ —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
  const target = new THREE.Vector3(0, 1, 0);
  const spherical = new THREE.Spherical(5, Math.PI / 3, 0); // r, phi, theta

  function updateCameraFromSpherical() {
    const sinPhiRadius = Math.sin(spherical.phi) * spherical.radius;
    camera.position.set(
      sinPhiRadius * Math.sin(spherical.theta),
      Math.cos(spherical.phi) * spherical.radius,
      sinPhiRadius * Math.cos(spherical.theta)
    );
    camera.lookAt(target);
  }
  updateCameraFromSpherical();

  // ===== –°–í–ï–¢ =====
  const hemiLight = new THREE.HemisphereLight(0xeaf3ff, 0x080814, 1.3);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
  dirLight.position.set(4, 8, 4);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 20;
  dirLight.shadow.camera.left = -7;
  dirLight.shadow.camera.right = 7;
  dirLight.shadow.camera.top = 7;
  dirLight.shadow.camera.bottom = -7;
  scene.add(dirLight);

  // ===== –ü–û–õ (–ü–û–î–ò–£–ú) =====
  const floorGeometry = new THREE.CircleGeometry(4, 64);
  const floorMaterial = new THREE.MeshStandardMaterial({
    color: 0x181c30,
    roughness: 0.7,
    metalness: 0.1
  });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  const glowGeometry = new THREE.CircleGeometry(1.3, 40);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0x7181ff,
    transparent: true,
    opacity: 0.35
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.rotation.x = -Math.PI / 2;
  glow.position.y = 0.01;
  scene.add(glow);

  // ===== –°–û–ó–î–ê–Å–ú –ú–ê–†–ò–ö–ê =====
  const marik = new THREE.Group();
  marik.position.y = 0.5;
  scene.add(marik);

  const mainColor = 0xb5c4ff;
  const bellyColor = 0xe4e9ff;
  const accentColor = 0x8b9bff;

  const matMain = new THREE.MeshStandardMaterial({
    color: mainColor,
    roughness: 0.45,
    metalness: 0.15
  });
  const matBelly = new THREE.MeshStandardMaterial({
    color: bellyColor,
    roughness: 0.5,
    metalness: 0.1
  });
  const matAccent = new THREE.MeshStandardMaterial({
    color: accentColor,
    roughness: 0.4,
    metalness: 0.2
  });
  const matEyes = new THREE.MeshStandardMaterial({
    color: 0x000000,
    roughness: 0.3,
    metalness: 0.7
  });
  const matNose = new THREE.MeshStandardMaterial({
    color: 0xff88aa,
    roughness: 0.5,
    metalness: 0.1
  });

  // –¢–µ–ª–æ
  const bodyGeom = new THREE.SphereGeometry(0.9, 32, 32);
  const body = new THREE.Mesh(bodyGeom, matMain);
  body.castShadow = true;
  body.receiveShadow = true;
  marik.add(body);

  // –ñ–∏–≤–æ—Ç–∏–∫
  const bellyGeom = new THREE.SphereGeometry(0.72, 32, 32);
  const belly = new THREE.Mesh(bellyGeom, matBelly);
  belly.position.set(0, -0.05, 0.28);
  belly.scale.set(1, 0.8, 1);
  belly.castShadow = true;
  marik.add(belly);

  // –ì–æ–ª–æ–≤–∞
  const headGeom = new THREE.SphereGeometry(0.6, 32, 32);
  const head = new THREE.Mesh(headGeom, matMain);
  head.position.set(0, 0.95, 0.05);
  head.castShadow = true;
  marik.add(head);

  // –£—à–∫–∏
  function makeEar(side) {
    const earGeom = new THREE.ConeGeometry(0.25, 0.55, 20);
    const ear = new THREE.Mesh(earGeom, matAccent);
    ear.castShadow = true;
    ear.position.set(0.30 * side, 1.35, -0.05);
    ear.rotation.z = -0.3 * side;
    return ear;
  }
  marik.add(makeEar(1));
  marik.add(makeEar(-1));

  // –ì–ª–∞–∑–∞
  function makeEye(side) {
    const eyeGeom = new THREE.SphereGeometry(0.08, 16, 16);
    const eye = new THREE.Mesh(eyeGeom, matEyes);
    eye.castShadow = true;
    eye.position.set(0.18 * side, 1.05, 0.43);
    return eye;
  }
  const leftEye = makeEye(-1);
  const rightEye = makeEye(1);
  marik.add(leftEye);
  marik.add(rightEye);

  function makeEyeHighlight(parentEye) {
    const g = new THREE.SphereGeometry(0.03, 8, 8);
    const m = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const highlight = new THREE.Mesh(g, m);
    highlight.position.set(0.02, 0.03, 0.05);
    parentEye.add(highlight);
  }
  makeEyeHighlight(leftEye);
  makeEyeHighlight(rightEye);

  // –ù–æ—Å
  const noseGeom = new THREE.ConeGeometry(0.07, 0.16, 16);
  const nose = new THREE.Mesh(noseGeom, matNose);
  nose.rotation.x = Math.PI / 2;
  nose.position.set(0, 0.98, 0.52);
  nose.castShadow = true;
  marik.add(nose);

  // –£–ª—ã–±–∫–∞
  const mouthGeom = new THREE.TorusGeometry(0.12, 0.01, 8, 30, Math.PI);
  const mouthMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
  const mouth = new THREE.Mesh(mouthGeom, mouthMat);
  mouth.rotation.set(Math.PI, 0, 0);
  mouth.position.set(0, 0.90, 0.50);
  marik.add(mouth);

  // –£—Å—ã
  function makeWhisker(side, offsetY, angle) {
    const g = new THREE.CylinderGeometry(0.004, 0.004, 0.6, 6);
    const m = new THREE.MeshStandardMaterial({ color: 0xe7ecff, metalness: 0.2 });
    const whisker = new THREE.Mesh(g, m);
    whisker.castShadow = true;
    whisker.position.set(0.35 * side, offsetY, 0.43);
    whisker.rotation.z = (Math.PI / 2) * side + angle * side;
    return whisker;
  }
  marik.add(makeWhisker(1, 1.0, 0.22));
  marik.add(makeWhisker(1, 0.95, 0.05));
  marik.add(makeWhisker(1, 0.90, -0.1));
  marik.add(makeWhisker(-1, 1.0, 0.22));
  marik.add(makeWhisker(-1, 0.95, 0.05));
  marik.add(makeWhisker(-1, 0.90, -0.1));

  // –õ–∞–ø—ã
  function makePaw(sideX, sideZ) {
    const g = new THREE.CylinderGeometry(0.15, 0.18, 0.35, 20);
    const paw = new THREE.Mesh(g, matMain);
    paw.castShadow = true;
    paw.position.set(0.35 * sideX, -0.3, 0.35 * sideZ);
    return paw;
  }
  marik.add(makePaw(1, 1));
  marik.add(makePaw(-1, 1));
  marik.add(makePaw(1, -1));
  marik.add(makePaw(-1, -1));

  // –•–≤–æ—Å—Ç
  const tailGeom = new THREE.CylinderGeometry(0.11, 0.16, 1.4, 16);
  const tail = new THREE.Mesh(tailGeom, matAccent);
  tail.castShadow = true;
  tail.position.set(0, -0.1, -0.86);
  tail.rotation.x = Math.PI / 2.2;
  tail.rotation.z = 0.2;
  marik.add(tail);

  const tailTipGeom = new THREE.SphereGeometry(0.16, 16, 16);
  const tailTip = new THREE.Mesh(tailTipGeom, matMain);
  tailTip.castShadow = true;
  tailTip.position.set(0, -0.7, 0);
  tail.add(tailTip);

  // ===== –û–ë–õ–ê–ö–û –†–ï–ß–ò =====
  const speech = document.getElementById("speech");
  let speechTimeout = null;

  function showSpeech(text, ms = 1000) {
    clearTimeout(speechTimeout);
    speech.textContent = text;
    speech.style.display = "block";
    speechTimeout = setTimeout(() => {
      speech.style.display = "none";
    }, ms);
  }

  // ===== –ò–ù–¢–ï–†–ê–ö–¢–ò–í =====
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let isHoveringMarik = false;
  let isAngry = false;
  let angryTimer = 0;
  let lastPetTime = 0;

  function updateMouse(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  }

  function checkHover() {
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObject(marik, true);
    isHoveringMarik = hits.length > 0;
  }

  window.addEventListener("pointermove", (e) => {
    updateMouse(e);
    checkHover();
    if (isHoveringMarik) {
      const now = performance.now();
      if (now - lastPetTime > 350) {
        lastPetTime = now;
        showSpeech("–º—Ä—Ä—Ä—Ä‚Ä¶ üíú", 700);
      }
    }
  });

  window.addEventListener("pointerdown", (e) => {
    updateMouse(e);
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObject(marik, true);
    if (hits.length > 0) {
      isAngry = true;
      angryTimer = performance.now();
      showSpeech("!!!###!!!???!!!", 1300);

      const start = performance.now();
      const initialPosX = marik.position.x;
      function shake(timestamp) {
        const t = timestamp - start;
        const power = Math.max(0, 1 - t / 300);
        marik.position.x = initialPosX + Math.sin(t * 0.06) * 0.07 * power;
        if (t < 300) requestAnimationFrame(shake);
        else marik.position.x = initialPosX;
      }
      requestAnimationFrame(shake);
    }
  });

  // ===== –†–£–ß–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô =====
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;

  renderer.domElement.addEventListener("pointerdown", (e) => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener("pointerup", () => {
    isDragging = false;
  });

  window.addEventListener("pointerleave", () => {
    isDragging = false;
  });

  window.addEventListener("pointermove", (e) => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    const ROT_SPEED = 0.005;
    spherical.theta -= dx * ROT_SPEED;
    spherical.phi -= dy * ROT_SPEED;

    const minPhi = 0.3;
    const maxPhi = Math.PI - 0.3;
    spherical.phi = Math.max(minPhi, Math.min(maxPhi, spherical.phi));

    updateCameraFromSpherical();
  });

  window.addEventListener("wheel", (e) => {
    const ZOOM_SPEED = 0.0015;
    spherical.radius += e.deltaY * ZOOM_SPEED * spherical.radius;
    spherical.radius = Math.max(3, Math.min(8, spherical.radius));
    updateCameraFromSpherical();
  }, { passive: true });

  // ===== –ê–ù–ò–ú–ê–¶–ò–Ø =====
  const clock = new THREE.Clock();
  const baseBodyScaleY = body.scale.y;
  const baseTailRotX = tail.rotation.x;
  let angryColorBoost = 0;

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // "–¥—ã—Ö–∞–Ω–∏–µ"
    const breathe = Math.sin(t * 2.0) * 0.03;
    body.scale.y = baseBodyScaleY + breathe;
    body.scale.x = 1 - breathe * 0.5;
    body.scale.z = 1 - breathe * 0.5;

    // –≥–æ–ª–æ–≤–∞
    head.position.y = 0.95 + Math.sin(t * 1.5) * 0.02;

    // —Ö–≤–æ—Å—Ç
    const tailWave = Math.sin(t * 3.0) * 0.35;
    tail.rotation.x = baseTailRotX + tailWave * 0.35;

    // –ª—ë–≥–∫–∏–π –ø–æ–≤–æ—Ä–æ—Ç –≤—Å–µ–≥–æ –ú–∞—Ä–∏–∫–∞
    marik.rotation.y = Math.sin(t * 0.4) * 0.25;

    // –∑–ª–æ—Å—Ç—å
    if (isAngry) {
      const elapsedAngry = performance.now() - angryTimer;
      const k = Math.max(0, 1 - elapsedAngry / 1200);
      angryColorBoost = k;
      marik.scale.set(1 + 0.12 * k, 1 + 0.12 * k, 1 + 0.12 * k);
      if (k <= 0.01) {
        isAngry = false;
        angryColorBoost = 0;
        marik.scale.set(1, 1, 1);
      }
    }

    const boostedMain = new THREE.Color(mainColor).lerp(new THREE.Color(0xff6666), angryColorBoost * 0.7);
    matMain.color.copy(boostedMain);
    const boostedAccent = new THREE.Color(accentColor).lerp(new THREE.Color(0xff3355), angryColorBoost * 0.7);
    matAccent.color.copy(boostedAccent);

    renderer.render(scene, camera);
  }

  animate();

  // ===== –†–ï–°–ê–ô–ó =====
  window.addEventListener("resize", () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>
