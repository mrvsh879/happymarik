<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ ‚Äî 3D –º–µ–º–æ–¥–∑–∏</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π 3D –ú–∞—Ä–∏–∫ –≤ —Å—Ç–∏–ª–µ –º–µ–º–æ–¥–∑–∏ ‚Äî –º–æ–∂–Ω–æ –∫—Ä—É—Ç–∏—Ç—å, –≥–ª–∞–¥–∏—Ç—å –∏ —Ç—ã–∫–∞—Ç—å." />
  <meta name="theme-color" content="#151826" />

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #3b5fff 0%, #151826 40%, #05060b 100%);
      color: #fff;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      touch-action: none;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    #ui {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
      padding: 0 16px;
    }
    #title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-shadow: 0 4px 18px rgba(0,0,0,0.65);
    }
    #subtitle {
      margin-top: 4px;
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 11px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
      z-index: 10;
      backdrop-filter: blur(12px);
      max-width: 90vw;
      justify-content: center;
    }
    #hints span {
      opacity: 0.9;
      display: inline-flex;
      gap: 4px;
      align-items: center;
      white-space: nowrap;
    }
    #speech {
      position: fixed;
      top: 78px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 18px;
      min-width: 120px;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      max-width: 90vw;
    }
    #error-msg {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #05060b;
      color: #fff;
      z-index: 100;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }

    @media (max-width: 600px) {
      #title { font-size: 22px; }
      #subtitle { font-size: 12px; }
      #speech { font-size: 16px; }
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <div id="title">–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ üßë‚Äçüé®</div>
  <div id="subtitle">–ü–æ–≥–ª–∞–¥—å –º–µ–Ω—è ‚Äî —è –∑–∞–º—É—Ä—á—É. –¢—ã–∫–Ω–∏ –≤ –º–µ–Ω—è ‚Äî —è –≤–æ–∑–º<strong>—É</strong>—â—É—Å—å!</div>
</div>

<div id="speech"></div>

<div id="hints">
  <span>üñ±Ô∏è –õ–ö–ú + –º—ã—à—å ‚Äî –∫—Ä—É—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</span>
  <span>üñ±Ô∏è –ö–æ–ª—ë—Å–∏–∫–æ ‚Äî –∑—É–º</span>
  <span>ü§ö –í–µ–¥–∏ –º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî –≥–ª–∞–¥—å</span>
  <span>üëÜ –ö–ª–∏–∫/—Ç–∞–ø –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî —Ä—É–≥–∞–µ—Ç—Å—è</span>
</div>

<div id="error-msg">
  <div>
    <div style="font-size:22px;margin-bottom:10px;">–£–ø—Å‚Ä¶ –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ üßØ</div>
    <div>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å 3D-—Å—Ü–µ–Ω—É. –ü–æ–ø—Ä–æ–±—É–π –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ (Chrome / Firefox / Edge).</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
  if (!window.THREE) {
    document.getElementById('error-msg').style.display = 'flex';
  } else {
    initHappyMarik();
  }

  function initHappyMarik() {
    // ===== –ë–ê–ó–ê =====
    const container = document.getElementById("canvas-container");

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x05060b, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060b, 6, 18);

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );

    const target = new THREE.Vector3(0, 1.3, 0);
    let camRadius = 4.8;
    let camYaw = 0.4;
    let camPitch = 0.9;

    function updateCamera() {
      const x = camRadius * Math.sin(camPitch) * Math.sin(camYaw);
      const y = camRadius * Math.cos(camPitch);
      const z = camRadius * Math.sin(camPitch) * Math.cos(camYaw);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }
    updateCamera();

    // ===== –°–í–ï–¢ =====
    const hemiLight = new THREE.HemisphereLight(0xf5f7ff, 0x080814, 1.25);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(4, 8, 4);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 20;
    dirLight.shadow.camera.left = -7;
    dirLight.shadow.camera.right = 7;
    dirLight.shadow.camera.top = 7;
    dirLight.shadow.camera.bottom = -7;
    scene.add(dirLight);

    // ===== –ü–û–õ =====
    const floorGeometry = new THREE.CircleGeometry(4, 64);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x181c30,
      roughness: 0.75,
      metalness: 0.05
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const glowGeometry = new THREE.CircleGeometry(1.6, 40);
    const glowMaterial = new THREE.MeshBasicMaterial({
      color: 0x5f9dff,
      transparent: true,
      opacity: 0.45
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    glow.rotation.x = -Math.PI / 2;
    glow.position.y = 0.01;
    scene.add(glow);

    // ===== –ü–ï–†–°–û–ù–ê–ñ ‚Äî –ù–û–í–´–ô –ú–ï–ú–û–î–ó–ò-–ú–ê–†–ò–ö =====
    const marik = new THREE.Group();
    marik.position.y = 0.55;
    scene.add(marik);

    // –ü–ê–õ–ò–¢–†–ê
    const skinColor = 0xffc9a8;
    const hairColor = 0x3a2620;
    const shirtColor = 0x4d7dff;
    const shirtAccent = 0x7ea2ff;
    const pantsColor = 0x1e2438;
    const shoeColor = 0x080a12;
    const cheekColor = 0xff9fb0;

    const matSkin = new THREE.MeshStandardMaterial({
      color: skinColor,
      roughness: 0.45,
      metalness: 0.05
    });
    const matHair = new THREE.MeshStandardMaterial({
      color: hairColor,
      roughness: 0.6,
      metalness: 0.1
    });
    const matShirt = new THREE.MeshStandardMaterial({
      color: shirtColor,
      roughness: 0.5,
      metalness: 0.18
    });
    const matShirtAccent = new THREE.MeshStandardMaterial({
      color: shirtAccent,
      roughness: 0.55,
      metalness: 0.15
    });
    const matPants = new THREE.MeshStandardMaterial({
      color: pantsColor,
      roughness: 0.65,
      metalness: 0.12
    });
    const matShoes = new THREE.MeshStandardMaterial({
      color: shoeColor,
      roughness: 0.75,
      metalness: 0.2
    });
    const matEyes = new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 0.3,
      metalness: 0.7
    });
    const matWhite = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.4,
      metalness: 0.1
    });
    const matMouth = new THREE.MeshStandardMaterial({
      color: 0xa14534,
      roughness: 0.5,
      metalness: 0.1
    });
    const matCheek = new THREE.MeshStandardMaterial({
      color: cheekColor,
      roughness: 0.7,
      metalness: 0.05
    });

    // –¢–û–†–°
    const torsoGeom = new THREE.CylinderGeometry(0.55, 0.6, 1.1, 32);
    const torso = new THREE.Mesh(torsoGeom, matShirt);
    torso.castShadow = true;
    torso.receiveShadow = true;
    torso.position.y = 0.1;
    marik.add(torso);

    // –ù–µ–±–æ–ª—å—à–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π ¬´–Ω–∏–∑¬ª —Ñ—É—Ç–±–æ–ª–∫–∏
    const hemGeom = new THREE.CylinderGeometry(0.6, 0.62, 0.12, 32);
    const hem = new THREE.Mesh(hemGeom, matShirtAccent);
    hem.castShadow = true;
    hem.position.y = -0.6;
    torso.add(hem);

    // –ü–õ–ï–ß–ò / –í–û–†–û–¢–ù–ò–ö
    const collarGeom = new THREE.TorusGeometry(0.37, 0.055, 18, 40);
    const collar = new THREE.Mesh(collarGeom, matShirtAccent);
    collar.position.y = 0.6;
    collar.rotation.x = Math.PI / 2;
    collar.castShadow = true;
    marik.add(collar);

    // –®–ï–Ø
    const neckGeom = new THREE.CylinderGeometry(0.23, 0.23, 0.22, 20);
    const neck = new THREE.Mesh(neckGeom, matSkin);
    neck.position.y = 0.87;
    neck.castShadow = true;
    marik.add(neck);

    // –ì–û–õ–û–í–ê ‚Äî –±–æ–ª—å—à–∞—è, –º–µ–º–æ–¥–∑–∏-—Å—Ç–∞–π–ª
    const headGeom = new THREE.SphereGeometry(0.7, 40, 40);
    const head = new THREE.Mesh(headGeom, matSkin);
    head.position.y = 1.45;
    head.castShadow = true;
    marik.add(head);

    // –í–û–õ–û–°–´ ‚Äî –∞–∫–∫—É—Ä–∞—Ç–Ω–∞—è ¬´—à–∞–ø–∫–∞¬ª
    const hairGeom = new THREE.SphereGeometry(0.71, 40, 40, 0, Math.PI * 2, 0, Math.PI / 1.7);
    const hair = new THREE.Mesh(hairGeom, matHair);
    hair.position.y = 1.52;
    hair.scale.z = 0.92;
    hair.castShadow = true;
    marik.add(hair);

    // –£–®–ò
    function makeEar(side) {
      const earGeom = new THREE.SphereGeometry(0.12, 20, 20);
      const ear = new THREE.Mesh(earGeom, matSkin);
      ear.castShadow = true;
      ear.position.set(0.63 * side, 1.43, 0);
      marik.add(ear);
      return ear;
    }
    makeEar(1);
    makeEar(-1);

    // –©–Å–ß–ö–ò
    function makeCheek(side) {
      const cheekGeom = new THREE.SphereGeometry(0.12, 16, 16);
      const cheek = new THREE.Mesh(cheekGeom, matCheek);
      cheek.position.set(0.3 * side, 1.32, 0.46);
      cheek.scale.set(1.2, 0.8, 1);
      cheek.castShadow = false;
      marik.add(cheek);
      return cheek;
    }
    makeCheek(1);
    makeCheek(-1);

    // –ì–õ–ê–ó–ê
    function makeEye(side) {
      const eyeWhiteGeom = new THREE.SphereGeometry(0.14, 20, 20);
      const white = new THREE.Mesh(eyeWhiteGeom, matWhite);
      white.position.set(0.23 * side, 1.42, 0.54);
      white.scale.y = 0.95;

      const pupilGeom = new THREE.SphereGeometry(0.08, 20, 20);
      const pupil = new THREE.Mesh(pupilGeom, matEyes);
      pupil.position.set(0, 0, 0.06);
      white.add(pupil);

      const highlightGeom = new THREE.SphereGeometry(0.03, 10, 10);
      const highlight = new THREE.Mesh(highlightGeom, new THREE.MeshBasicMaterial({ color: 0xffffff }));
      highlight.position.set(0.03, 0.04, 0.04);
      pupil.add(highlight);

      marik.add(white);
      return { white, pupil };
    }
    const leftEye = makeEye(-1);
    const rightEye = makeEye(1);

    // –ë–†–û–í–ò
    function makeBrow(side) {
      const browGeom = new THREE.BoxGeometry(0.32, 0.07, 0.06);
      const brow = new THREE.Mesh(browGeom, matHair);
      brow.position.set(0.25 * side, 1.58, 0.43);
      brow.castShadow = true;
      marik.add(brow);
      return brow;
    }
    const leftBrow = makeBrow(-1);
    const rightBrow = makeBrow(1);

    // –ù–û–°
    const noseGeom = new THREE.ConeGeometry(0.08, 0.2, 22);
    const nose = new THREE.Mesh(noseGeom, matSkin);
    nose.rotation.x = Math.PI / 2;
    nose.position.set(0, 1.36, 0.6);
    nose.castShadow = true;
    marik.add(nose);

    // –†–û–¢ ‚Äî –º—è–≥–∫–∞—è —É–ª—ã–±–∫–∞
    const mouthGeom = new THREE.TorusGeometry(0.22, 0.05, 18, 40, Math.PI);
    const mouth = new THREE.Mesh(mouthGeom, matMouth);
    mouth.rotation.set(Math.PI, 0, 0);
    mouth.position.set(0, 1.23, 0.54);
    marik.add(mouth);

    const tongueGeom = new THREE.SphereGeometry(0.1, 20, 20, 0, Math.PI, 0, Math.PI);
    const tongue = new THREE.Mesh(
      tongueGeom,
      new THREE.MeshStandardMaterial({ color: 0xff7d9a, roughness: 0.6 })
    );
    tongue.position.set(0, -0.04, 0.07);
    mouth.add(tongue);

    // –†–£–ö–ò
    function makeArm(side) {
      const upperGeom = new THREE.CylinderGeometry(0.16, 0.18, 0.8, 22);
      const upper = new THREE.Mesh(upperGeom, matShirt);
      upper.castShadow = true;
      upper.position.set(0.6 * side, 0.25, 0);
      upper.rotation.z = side * -0.2;

      const foreGeom = new THREE.CylinderGeometry(0.13, 0.14, 0.75, 22);
      const fore = new THREE.Mesh(foreGeom, matSkin);
      fore.castShadow = true;
      fore.position.set(0, -0.5, 0.08);
      fore.rotation.x = 0.25;
      upper.add(fore);

      const handGeom = new THREE.SphereGeometry(0.17, 18, 18);
      const hand = new THREE.Mesh(handGeom, matSkin);
      hand.castShadow = true;
      hand.position.set(0, -0.45, 0.08);
      fore.add(hand);

      marik.add(upper);
      return { upper, fore, hand };
    }
    const leftArm = makeArm(-1);
    const rightArm = makeArm(1);

    // –ù–û–ì–ò
    function makeLeg(side) {
      const upperLegGeom = new THREE.CylinderGeometry(0.18, 0.2, 0.7, 20);
      const leg = new THREE.Mesh(upperLegGeom, matPants);
      leg.castShadow = true;
      leg.position.set(0.27 * side, -0.75, 0.08);

      const shoeGeom = new THREE.BoxGeometry(0.44, 0.25, 0.75);
      const shoe = new THREE.Mesh(shoeGeom, matShoes);
      shoe.castShadow = true;
      shoe.position.set(0, -0.45, 0.25);
      leg.add(shoe);

      marik.add(leg);
      return { leg, shoe };
    }
    makeLeg(-1);
    makeLeg(1);

    // ===== –û–ë–õ–ê–ö–û –†–ï–ß–ò =====
    const speech = document.getElementById("speech");
    let speechTimeout = null;

    function showSpeech(text, ms = 1000) {
      clearTimeout(speechTimeout);
      speech.textContent = text;
      speech.style.display = "block";
      speechTimeout = setTimeout(() => {
        speech.style.display = "none";
      }, ms);
    }

    // ===== –ò–ù–¢–ï–†–ê–ö–¢–ò–í =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isHoveringMarik = false;
    let isAngry = false;
    let angryTimer = 0;
    let lastPetTime = 0;

    function updateMouse(evt) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function checkHover() {
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      isHoveringMarik = hits.length > 0;
    }

    window.addEventListener("pointermove", (e) => {
      updateMouse(e);
      checkHover();
      if (isHoveringMarik) {
        const now = performance.now();
        if (now - lastPetTime > 350) {
          lastPetTime = now;
          showSpeech("–º—Ä—Ä—Ä—Ä‚Ä¶ üíú", 700);
        }
      }
    });

    window.addEventListener("pointerdown", (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      if (hits.length > 0) {
        isAngry = true;
        angryTimer = performance.now();
        showSpeech("!!!###!!!???!!!", 1300);

        const start = performance.now();
        const initialPosX = marik.position.x;
        function shake(timestamp) {
          const t = timestamp - start;
          const power = Math.max(0, 1 - t / 300);
          marik.position.x = initialPosX + Math.sin(t * 0.06) * 0.07 * power;
          if (t < 300) requestAnimationFrame(shake);
          else marik.position.x = initialPosX;
        }
        requestAnimationFrame(shake);
      }
    });

    // ===== –ö–ê–ú–ï–†–ê =====
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    window.addEventListener("pointerup", () => {
      isDragging = false;
    });

    window.addEventListener("pointerleave", () => {
      isDragging = false;
    });

    window.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const ROT_SPEED = 0.005;
      camYaw -= dx * ROT_SPEED;
      camPitch -= dy * ROT_SPEED;

      const minPitch = 0.4;
      const maxPitch = Math.PI - 0.4;
      camPitch = Math.max(minPitch, Math.min(maxPitch, camPitch));

      updateCamera();
    });

    window.addEventListener("wheel", (e) => {
      const ZOOM_SPEED = 0.0015;
      camRadius += e.deltaY * ZOOM_SPEED * camRadius;
      camRadius = Math.max(3.2, Math.min(7, camRadius));
      updateCamera();
    }, { passive: true });

    // ===== –ê–ù–ò–ú–ê–¶–ò–Ø =====
    const clock = new THREE.Clock();
    const baseTorsoScaleY = torso.scale.y;
    const baseLeftBrowY = leftBrow.position.y;
    const baseRightBrowY = rightBrow.position.y;
    let angryColorBoost = 0;

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // –¥—ã—Ö–∞–Ω–∏–µ/–ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ
      const breathe = Math.sin(t * 2.0) * 0.03;
      torso.scale.y = baseTorsoScaleY + breathe;
      torso.position.y = 0.1 + breathe * 0.15;
      marik.position.y = 0.55 + Math.sin(t * 1.7) * 0.02;

      // —Ä—É–∫–∏
      const handWave = Math.sin(t * 2.5) * 0.08;
      leftArm.upper.rotation.z = -0.2 - handWave * 0.6;
      rightArm.upper.rotation.z = 0.2 + handWave * 0.6;

      // –ª—ë–≥–∫–∏–π –Ω–∞–∫–ª–æ–Ω –≥–æ–ª–æ–≤—ã
      head.rotation.z = Math.sin(t * 1.2) * 0.03;

      // –º–æ—Ä–≥–∞–Ω–∏–µ
      const blinkPeriod = 3.5;
      const blinkTime = t % blinkPeriod;
      let eyeScaleY = 1.0;
      if (blinkTime < 0.12) {
        const k = Math.sin((blinkTime / 0.12) * Math.PI);
        eyeScaleY = 1 - k * 0.85;
      }
      leftEye.white.scale.y = eyeScaleY;
      rightEye.white.scale.y = eyeScaleY;

      // –∑–ª–æ—Å—Ç—å
      if (isAngry) {
        const elapsed = performance.now() - angryTimer;
        const k = Math.max(0, 1 - elapsed / 1200);
        angryColorBoost = k;
        marik.scale.set(1 + 0.09 * k, 1 + 0.09 * k, 1 + 0.09 * k);

        leftBrow.position.y = baseLeftBrowY + 0.13 * k;
        rightBrow.position.y = baseRightBrowY + 0.13 * k;
        leftBrow.rotation.z = -0.25 * k;
        rightBrow.rotation.z = 0.25 * k;

        if (k <= 0.01) {
          isAngry = false;
          angryColorBoost = 0;
          marik.scale.set(1, 1, 1);
          leftBrow.position.y = baseLeftBrowY;
          rightBrow.position.y = baseRightBrowY;
          leftBrow.rotation.z = 0;
          rightBrow.rotation.z = 0;
        }
      }

      const boostedShirt = new THREE.Color(shirtColor).lerp(new THREE.Color(0xff6666), angryColorBoost * 0.7);
      matShirt.color.copy(boostedShirt);

      renderer.render(scene, camera);
    }

    animate();

    // ===== –†–ï–°–ê–ô–ó =====
    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  }
</script>
</body>
</html>
