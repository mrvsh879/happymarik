<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ ‚Äî 3D MVP</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="description" content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π 3D –ú–∞—Ä–∏–∫ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–∂, –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –∫—Ä—É—Ç–∏—Ç—å, –≥–ª–∞–¥–∏—Ç—å –∏ —Ç—ã–∫–∞—Ç—å." />
  <meta name="theme-color" content="#151826" />

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #3b5fff 0%, #151826 40%, #05060b 100%);
      color: #fff;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      touch-action: none;
    }
    #canvas-container {
      position: fixed;
      inset: 0;
    }
    #ui {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
      padding: 0 16px;
    }
    #title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-shadow: 0 4px 18px rgba(0,0,0,0.65);
    }
    #subtitle {
      margin-top: 4px;
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    #hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 11px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
      z-index: 10;
      backdrop-filter: blur(12px);
      max-width: 90vw;
      justify-content: center;
    }
    #hints span {
      opacity: 0.9;
      display: inline-flex;
      gap: 4px;
      align-items: center;
      white-space: nowrap;
    }
    #speech {
      position: fixed;
      top: 78px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 18px;
      min-width: 120px;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      max-width: 90vw;
    }
    #error-msg {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #05060b;
      color: #fff;
      z-index: 100;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }
    /* –ú—É—Ä—á–æ–º–µ—Ç—Ä */
    #mood-pill {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 10;
      backdrop-filter: blur(10px);
      max-width: 90vw;
      white-space: nowrap;
    }
    #mood-emoji {
      font-size: 16px;
    }
    @media (max-width: 600px) {
      #title { font-size: 22px; }
      #subtitle { font-size: 12px; }
      #speech { font-size: 16px; }
      #mood-pill { font-size: 11px; bottom: 68px; }
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <div id="title">–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ú–∞—Ä–∏–∫ üßç‚Äç‚ôÇÔ∏è</div>
  <div id="subtitle">–ü–æ–≥–ª–∞–¥—å –º–µ–Ω—è ‚Äî —è –∑–∞–º—É—Ä—á—É. –¢—ã–∫–Ω–∏ –≤ –º–µ–Ω—è ‚Äî —è –≤–æ–∑–º<strong>—É</strong>—â—É—Å—å!</div>
</div>

<div id="speech"></div>

<!-- –ú—É—Ä—á–æ–º–µ—Ç—Ä -->
<div id="mood-pill">
  <span id="mood-emoji">üôÇ</span>
  <span id="mood-text">–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: 0</span>
</div>

<div id="hints">
  <span>üñ±Ô∏è –õ–ö–ú + –º—ã—à—å ‚Äî –∫—Ä—É—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</span>
  <span>üñ±Ô∏è –ö–æ–ª—ë—Å–∏–∫–æ ‚Äî –∑—É–º</span>
  <span>ü§ö –í–µ–¥–∏ –º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî –≥–ª–∞–¥—å</span>
  <span>üëÜ –ö–ª–∏–∫/—Ç–∞–ø –ø–æ –ú–∞—Ä–∏–∫—É ‚Äî —Ä—É–≥–∞–µ—Ç—Å—è</span>
</div>

<div id="error-msg">
  <div>
    <div style="font-size:22px;margin-bottom:10px;">–£–ø—Å‚Ä¶ –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ üßØ</div>
    <div>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å 3D-—Å—Ü–µ–Ω—É. –ü–æ–ø—Ä–æ–±—É–π –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ.</div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "./three.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { FBXLoader } from './FBXLoader.js';

  const errorMsg = document.getElementById('error-msg');
  const speech = document.getElementById("speech");
  const moodEmojiEl = document.getElementById("mood-emoji");
  const moodTextEl = document.getElementById("mood-text");

  const petPhrases = [
    "–º—Ä—Ä—Ä‚Ä¶ üíú",
    "–æ –¥–∞‚Ä¶ –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Å—è üòå",
    "—Ç–∞–∫-—Ç–æ –ª—É—á—à–µ",
    "—è –≤—Å–µ–≥–¥–∞ –∑–Ω–∞–ª, —á—Ç–æ —Ç—ã –¥–æ–±—Ä—ã–π",
    "–µ—â—ë —á—É—Ç—å-—á—É—Ç—å‚Ä¶"
  ];
  const angryPhrases = [
    "!!!###!!!???!!!",
    "@#$%!!!",
    "—Ç—ã —á—ë –¥–µ–ª–∞–µ—à—å?!",
    "–Ω—É –∑–∞ —á—Ç–æ?!!",
    "—ç–π! –∞–∫–∫—É—Ä–∞—Ç–Ω–µ–µ!"
  ];
  const kneelPhrases = [
    "–ª–∞–¥–Ω–æ, –ª–∞–¥–Ω–æ‚Ä¶ —è —Å–¥–∞—é—Å—å üò¢",
    "—Ç–æ–ª—å–∫–æ –Ω–µ –±–µ–π –±–æ–ª—å—à–µ‚Ä¶",
    "–ø—Ä–æ—Å—Ç–∏, –¥–∞–≤–∞–π –º–∏—Ä üòî"
  ];
  const dancePhrases = [
    "–æ –¥–∞, –≤–æ—Ç —ç—Ç–æ –≤–∞–π–± üíÉ",
    "—è —Ç–∞–Ω—Ü—É—é, –∫–æ–≥–¥–∞ —Å—á–∞—Å—Ç–ª–∏–≤!",
    "–¥–µ—Ä–∂–∏ —Ä–∏—Ç–º üî•"
  ];

  // –ú—É—Ä—á–æ–º–µ—Ç—Ä
  let mood = 0; // -100..100
  const MOOD_MIN = -100;
  const MOOD_MAX = 100;

  function clampMood() {
    if (mood < MOOD_MIN) mood = MOOD_MIN;
    if (mood > MOOD_MAX) mood = MOOD_MAX;
  }

  function updateMoodUI() {
    clampMood();
    let emoji = "üôÇ";
    if (mood > 40) emoji = "üòä";
    else if (mood < 0) emoji = "üò†";
    moodEmojiEl.textContent = emoji;
    moodTextEl.textContent = `–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: ${mood}`;
  }

  updateMoodUI();

  function showSpeech(text, ms = 1000) {
    clearTimeout(showSpeech._timeout);
    speech.textContent = text;
    speech.style.display = "block";
    showSpeech._timeout = setTimeout(() => {
      speech.style.display = "none";
    }, ms);
  }

  try {
    initHappyMarik();
  } catch (e) {
    console.error(e);
    errorMsg.style.display = 'flex';
  }

  function initHappyMarik() {
    const container = document.getElementById("canvas-container");

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x05060b, 1);
    container.appendChild(renderer.domElement);
    renderer.domElement.style.cursor = 'grab';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060b, 6, 18);

    // === –û–§–ò–°–ù–´–ô 3D-–§–û–ù ===
    const backgroundGroup = new THREE.Group();
    scene.add(backgroundGroup);
    let plant = null; // –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä–∞—Å—Ç–µ–Ω–∏—è –≤ animate()

    // –ü–æ–ª –æ—Ñ–∏—Å–∞
    const officeFloorGeom = new THREE.PlaneGeometry(12, 10);
    const officeFloorMat = new THREE.MeshStandardMaterial({
      color: 0x2b2f3a,
      roughness: 1.0,
      metalness: 0.0
    });
    const officeFloor = new THREE.Mesh(officeFloorGeom, officeFloorMat);
    officeFloor.rotation.x = -Math.PI / 2;
    officeFloor.position.y = 0;
    officeFloor.receiveShadow = false;
    backgroundGroup.add(officeFloor);

    // –ó–∞–¥–Ω—è—è —Å—Ç–µ–Ω–∞
    const backWallGeom = new THREE.PlaneGeometry(12, 6);
    const backWallMat = new THREE.MeshStandardMaterial({
      color: 0x1f2230,
      roughness: 0.9,
      metalness: 0.05
    });
    const backWall = new THREE.Mesh(backWallGeom, backWallMat);
    backWall.position.set(0, 3, -5);
    backWall.receiveShadow = false;
    backgroundGroup.add(backWall);

    // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
    const leftWallGeom = new THREE.PlaneGeometry(10, 6);
    const leftWallMat = new THREE.MeshStandardMaterial({
      color: 0x212433,
      roughness: 0.85,
      metalness: 0.05
    });
    const leftWall = new THREE.Mesh(leftWallGeom, leftWallMat);
    leftWall.position.set(-6, 3, 0);
    leftWall.rotation.y = Math.PI / 2;
    backgroundGroup.add(leftWall);

    // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
    const rightWallGeom = new THREE.PlaneGeometry(10, 6);
    const rightWallMat = new THREE.MeshStandardMaterial({
      color: 0x262a3a,
      roughness: 0.8,
      metalness: 0.08
    });
    const rightWall = new THREE.Mesh(rightWallGeom, rightWallMat);
    rightWall.position.set(6, 3, 0);
    rightWall.rotation.y = -Math.PI / 2;
    backgroundGroup.add(rightWall);

    // "–û–∫–Ω–æ" –Ω–∞ –∑–∞–¥–Ω–µ–π —Å—Ç–µ–Ω–µ
    const windowGeom = new THREE.PlaneGeometry(4, 2);
    const windowMat = new THREE.MeshStandardMaterial({
      color: 0x11131e,
      emissive: 0x1f5cff,
      emissiveIntensity: 0.35,
      metalness: 0.2,
      roughness: 0.4
    });
    const windowMesh = new THREE.Mesh(windowGeom, windowMat);
    windowMesh.position.set(-2.5, 3.2, -4.99);
    backgroundGroup.add(windowMesh);

    // –†–∞–º—ã –æ–∫–Ω–∞
    const frameMat = new THREE.MeshStandardMaterial({
      color: 0x101219,
      metalness: 0.2,
      roughness: 0.7
    });
    const frameHGeom = new THREE.BoxGeometry(4.2, 0.07, 0.08);
    const frameVGeom = new THREE.BoxGeometry(0.07, 2.1, 0.08);

    const frameTop = new THREE.Mesh(frameHGeom, frameMat);
    frameTop.position.set(-2.5, 4.25, -4.98);
    const frameBottom = frameTop.clone();
    frameBottom.position.y = 2.15;

    const frameLeft = new THREE.Mesh(frameVGeom, frameMat);
    frameLeft.position.set(-4.6, 3.2, -4.98);
    const frameRight = frameLeft.clone();
    frameRight.position.x = -0.4;

    backgroundGroup.add(frameTop, frameBottom, frameLeft, frameRight);

    // –°—Ç–æ–ª
    const deskTopGeom = new THREE.BoxGeometry(3.2, 0.12, 1.4);
    const deskTopMat = new THREE.MeshStandardMaterial({
      color: 0x383c4a,
      roughness: 0.7,
      metalness: 0.15
    });
    const deskTop = new THREE.Mesh(deskTopGeom, deskTopMat);
    deskTop.position.set(1.8, 1.0, -1.5);
    deskTop.castShadow = true;
    deskTop.receiveShadow = true;
    backgroundGroup.add(deskTop);

    const deskLegGeom = new THREE.BoxGeometry(0.12, 1.0, 0.12);
    const deskLegMat = new THREE.MeshStandardMaterial({
      color: 0x232733,
      roughness: 0.8,
      metalness: 0.1
    });
    const legOffsets = [
      [-1.45, -0.6],
      [1.45, -0.6],
      [-1.45, 0.6],
      [1.45, 0.6]
    ];
    for (const [dx, dz] of legOffsets) {
      const leg = new THREE.Mesh(deskLegGeom, deskLegMat);
      leg.position.set(deskTop.position.x + dx, 0.5, deskTop.position.z + dz);
      leg.castShadow = true;
      leg.receiveShadow = true;
      backgroundGroup.add(leg);
    }

    // –ú–æ–Ω–∏—Ç–æ—Ä
    const monitorGeom = new THREE.BoxGeometry(1.4, 0.85, 0.05);
    const monitorMat = new THREE.MeshStandardMaterial({
      color: 0x111319,
      emissive: 0x2f8dff,
      emissiveIntensity: 0.7,
      metalness: 0.4,
      roughness: 0.3
    });
    const monitor = new THREE.Mesh(monitorGeom, monitorMat);
    monitor.position.set(deskTop.position.x, deskTop.position.y + 0.65, deskTop.position.z - 0.15);
    monitor.castShadow = true;
    backgroundGroup.add(monitor);

    const monitorStandGeom = new THREE.BoxGeometry(0.12, 0.4, 0.12);
    const monitorStand = new THREE.Mesh(monitorStandGeom, deskLegMat);
    monitorStand.position.set(deskTop.position.x, deskTop.position.y + 0.25, deskTop.position.z);
    monitorStand.castShadow = true;
    monitorStand.receiveShadow = true;
    backgroundGroup.add(monitorStand);

    // –°—Ç—É–ª
    const chairSeatGeom = new THREE.BoxGeometry(0.9, 0.12, 0.9);
    const chairSeatMat = new THREE.MeshStandardMaterial({
      color: 0x303546,
      roughness: 0.7,
      metalness: 0.2
    });
    const chairSeat = new THREE.Mesh(chairSeatGeom, chairSeatMat);
    chairSeat.position.set(1.8, 0.6, -0.3);
    chairSeat.castShadow = true;
    chairSeat.receiveShadow = true;
    backgroundGroup.add(chairSeat);

    const chairBackGeom = new THREE.BoxGeometry(0.9, 1.0, 0.12);
    const chairBack = new THREE.Mesh(chairBackGeom, chairSeatMat);
    chairBack.position.set(chairSeat.position.x, chairSeat.position.y + 0.56, chairSeat.position.z + 0.45);
    chairBack.castShadow = true;
    backgroundGroup.add(chairBack);

    const chairLegGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 12);
    const chairLegMat = new THREE.MeshStandardMaterial({
      color: 0x1f222b,
      roughness: 0.5,
      metalness: 0.6
    });
    const chairLeg = new THREE.Mesh(chairLegGeom, chairLegMat);
    chairLeg.position.set(chairSeat.position.x, 0.25, chairSeat.position.z);
    chairLeg.castShadow = true;
    chairLeg.receiveShadow = true;
    backgroundGroup.add(chairLeg);

    const chairBaseGeom = new THREE.BoxGeometry(0.7, 0.06, 0.06);
    const chairBase1 = new THREE.Mesh(chairBaseGeom, chairLegMat);
    chairBase1.position.set(chairSeat.position.x, 0.03, chairSeat.position.z);
    const chairBase2 = chairBase1.clone();
    chairBase2.rotation.y = Math.PI / 2;
    backgroundGroup.add(chairBase1, chairBase2);

    // –†–∞—Å—Ç–µ–Ω–∏–µ
    const potGeom = new THREE.CylinderGeometry(0.2, 0.26, 0.3, 12);
    const potMat = new THREE.MeshStandardMaterial({
      color: 0x44414a,
      roughness: 0.8,
      metalness: 0.2
    });
    const pot = new THREE.Mesh(potGeom, potMat);
    pot.position.set(-3.5, 0.15, -2.0);
    pot.castShadow = true;
    pot.receiveShadow = true;
    backgroundGroup.add(pot);

    const plantGeom = new THREE.ConeGeometry(0.45, 1.0, 14);
    const plantMat = new THREE.MeshStandardMaterial({
      color: 0x36b86c,
      roughness: 0.5,
      metalness: 0.1
    });
    plant = new THREE.Mesh(plantGeom, plantMat);
    plant.position.set(pot.position.x, pot.position.y + 0.75, pot.position.z);
    plant.castShadow = true;
    backgroundGroup.add(plant);

    // === –ö–ê–ú–ï–†–ê –ò –°–í–ï–¢ –î–ê–õ–¨–®–ï –ö–ê–ö –ë–´–õ–û ===
    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );

    const target = new THREE.Vector3(0, 1.2, 0);
    let camRadius = 5;
    let camYaw = 0.4;
    let camPitch = 0.9;

    function updateCamera() {
      const x = camRadius * Math.sin(camPitch) * Math.sin(camYaw);
      const y = camRadius * Math.cos(camPitch);
      const z = camRadius * Math.sin(camPitch) * Math.cos(camYaw);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }
    updateCamera();

    const hemiLight = new THREE.HemisphereLight(0xf5f7ff, 0x080814, 1.25);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(4, 8, 4);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 20;
    dirLight.shadow.camera.left = -7;
    dirLight.shadow.camera.right = 7;
    dirLight.shadow.camera.top = 7;
    dirLight.shadow.camera.bottom = -7;
    scene.add(dirLight);

    // –¢–Å–ú–ù–´–ô –ö–†–£–ì-–ü–û–õ –ü–û–î –ú–ê–†–ò–ö–û–ú ‚Äî –î–ï–õ–ê–ï–ú –ï–ì–û –ü–û–õ–ù–û–°–¢–¨–Æ –ü–†–û–ó–†–ê–ß–ù–´–ú
    const floorGeom = new THREE.CircleGeometry(4, 64);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x181c30,
      roughness: 0.75,
      metalness: 0.05,
      transparent: true,
      opacity: 0.0   // <-- –∫—Ä—É–≥ –µ—Å—Ç—å –≤ —Å—Ü–µ–Ω–µ, –Ω–æ –Ω–µ–≤–∏–¥–∏–º—ã–π
    });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // –ú–∞–ª–µ–Ω—å–∫–∏–π –≥–æ–ª—É–±–æ–π —Å–≤–µ—Ç—è—â–∏–π—Å—è –∫—Ä—É–≥ (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
    const glowGeom = new THREE.CircleGeometry(1.6, 40);
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x5f9dff,
      transparent: true,
      opacity: 0.45
    });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    glow.rotation.x = -Math.PI / 2;
    glow.position.y = 0.01;
    scene.add(glow);

    const marik = new THREE.Group();
    marik.position.y = 0;
    scene.add(marik);

    const loader = new FBXLoader();
    let mixer = null;
    let idleAction = null;
    let fallAction = null;
    let kneelAction = null;
    let danceAction = null;

    let isKneeling = false;
    let isDancing = false;

    function stopDance() {
      if (isDancing && danceAction && idleAction) {
        danceAction.fadeOut(0.25);
        idleAction.reset().fadeIn(0.25).play();
      }
      isDancing = false;
    }

    function maybeStartDance() {
      if (mood >= 45 && !isKneeling && danceAction && idleAction && !isDancing) {
        isDancing = true;
        idleAction.fadeOut(0.25);
        danceAction.reset().fadeIn(0.25).play();
        const phrase = dancePhrases[Math.floor(Math.random() * dancePhrases.length)];
        showSpeech(phrase, 1200);
      }
    }

    loader.load(
      'marik_idle.fbx',
      (fbx) => {
        const s = 0.01;
        fbx.scale.set(s, s, s);
        fbx.position.set(0, 0, 0);

        fbx.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        marik.add(fbx);

        if (fbx.animations && fbx.animations.length > 0) {
          mixer = new THREE.AnimationMixer(fbx);
          idleAction = mixer.clipAction(fbx.animations[0]);
          idleAction.play();
        }

        // –ø–∞–¥–µ–Ω–∏–µ
        loader.load(
          'marik_fall.fbx',
          (fallFbx) => {
            if (fallFbx.animations && fallFbx.animations.length > 0 && mixer) {
              const fallClip = fallFbx.animations[0];
              fallAction = mixer.clipAction(fallClip);
              fallAction.loop = THREE.LoopOnce;
              fallAction.clampWhenFinished = true;
            }
          },
          undefined,
          () => {}
        );

        // –∫–æ–ª–µ–Ω–∏
        loader.load(
          'marik_kneel.fbx',
          (kneelFbx) => {
            if (kneelFbx.animations && kneelFbx.animations.length > 0 && mixer) {
              const kneelClip = kneelFbx.animations[0];
              kneelAction = mixer.clipAction(kneelClip);
              kneelAction.loop = THREE.LoopOnce;
              kneelAction.clampWhenFinished = true;
            }
          },
          undefined,
          () => {}
        );

        // —Ç–∞–Ω–µ—Ü
        loader.load(
          'marik_dance.fbx',
          (danceFbx) => {
            if (danceFbx.animations && danceFbx.animations.length > 0 && mixer) {
              const danceClip = danceFbx.animations[0];
              danceAction = mixer.clipAction(danceClip);
              danceAction.loop = THREE.LoopRepeat;
              danceAction.clampWhenFinished = false;
              danceAction.enabled = true;
              danceAction.weight = 1.0;
              danceAction.timeScale = 1.0;
            }
          },
          undefined,
          () => {}
        );

      },
      undefined,
      (err) => {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ FBX:', err);
        errorMsg.style.display = 'flex';
      }
    );

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isHoveringMarik = false;
    let lastPetTime = 0;

    function updateMouse(evt) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function checkHover() {
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      isHoveringMarik = hits.length > 0;

      if (isHoveringMarik && !isDragging) {
        renderer.domElement.style.cursor = 'pointer';
      } else if (!isDragging) {
        renderer.domElement.style.cursor = 'grab';
      }
    }

    // –ø–æ–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
    window.addEventListener("pointermove", (e) => {
      updateMouse(e);
      checkHover();
      if (isHoveringMarik) {
        const now = performance.now();
        if (now - lastPetTime > 350) {
          lastPetTime = now;

          mood += 10;
          clampMood();
          updateMoodUI();

          const phrase = petPhrases[Math.floor(Math.random() * petPhrases.length)];
          showSpeech(phrase, 800);

          // –µ—Å–ª–∏ –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ–¥–Ω—è–ª–æ—Å—å ‚Äî –≤—Å—Ç–∞—ë—Ç
          if (isKneeling && mood > -10 && kneelAction && idleAction && mixer) {
            kneelAction.fadeOut(0.3);
            idleAction.reset().fadeIn(0.3).play();
            isKneeling = false;
          }

          // –º–æ–∂–µ—Ç –Ω–∞—á–∞—Ç—å —Ç–∞–Ω—Ü–µ–≤–∞—Ç—å
          maybeStartDance();
        }
      }
    });

    function triggerKneel() {
      if (!kneelAction || !idleAction || !mixer || isKneeling) return;

      isKneeling = true;
      stopDance(); // –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö –Ω–µ —Ç–∞–Ω—Ü—É–µ–º

      if (fallAction) fallAction.stop();
      idleAction.fadeOut(0.2);
      kneelAction.reset().fadeIn(0.25).play();

      const phrase = kneelPhrases[Math.floor(Math.random() * kneelPhrases.length)];
      showSpeech(phrase, 1500);
    }

    // —É–¥–∞—Ä—ã
    window.addEventListener("pointerdown", (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(marik, true);
      if (hits.length > 0) {
        mood -= 25;
        clampMood();
        updateMoodUI();

        // –µ—Å–ª–∏ –±—ã–ª –≤ —Ç–∞–Ω—Ü–µ, –∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —É–ø–∞–ª–æ ‚Äî –ø–µ—Ä–µ—Å—Ç–∞—ë—Ç —Ç–∞–Ω—Ü–µ–≤–∞—Ç—å
        if (mood < 35) {
          stopDance();
        }

        // —Å–∏–ª—å–Ω—ã–π –º–∏–Ω—É—Å ‚Äî –Ω–∞ –∫–æ–ª–µ–Ω–∏
        if (mood <= -60) {
          triggerKneel();
        } else {
          // –æ–±—ã—á–Ω–∞—è –∑–ª–∞—è —Ä–µ–∞–∫—Ü–∏—è —Å –ø–∞–¥–µ–Ω–∏–µ–º (–µ—Å–ª–∏ –Ω–µ –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö)
          const phrase = angryPhrases[Math.floor(Math.random() * angryPhrases.length)];
          showSpeech(phrase, 1300);

          if (!isKneeling && fallAction && idleAction && mixer) {
            stopDance();
            idleAction.fadeOut(0.15);
            fallAction.reset().fadeIn(0.1).play();

            setTimeout(() => {
              fallAction.fadeOut(0.25);
              idleAction.reset().fadeIn(0.25).play();
            }, 900);
          }
        }

        // —Ç—Ä—è—Å–∫–∞
        const start = performance.now();
        const initialPosX = marik.position.x;
        const badFactor = 1 + Math.max(0, -mood / 100);
        function shake(timestamp) {
          const t = timestamp - start;
          const power = Math.max(0, 1 - t / 300);
          marik.position.x = initialPosX + Math.sin(t * 0.06) * 0.07 * power * badFactor;
          if (t < 300) requestAnimationFrame(shake);
          else marik.position.x = initialPosX;
        }
        requestAnimationFrame(shake);
      }
    });

    // –∫–∞–º–µ—Ä–∞ + –∫—É—Ä—Å–æ—Ä
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      renderer.domElement.style.cursor = 'grabbing';
    });

    window.addEventListener("pointerup", () => {
      isDragging = false;
      renderer.domElement.style.cursor = isHoveringMarik ? 'pointer' : 'grab';
    });

    window.addEventListener("pointerleave", () => {
      isDragging = false;
      renderer.domElement.style.cursor = isHoveringMarik ? 'pointer' : 'grab';
    });

    window.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const ROT_SPEED = 0.005;
      camYaw -= dx * ROT_SPEED;
      camPitch -= dy * ROT_SPEED;

      const minPitch = 0.4;
      const maxPitch = Math.PI - 0.4;
      camPitch = Math.max(minPitch, Math.min(maxPitch, camPitch));

      updateCamera();
    });

    window.addEventListener("wheel", (e) => {
      const ZOOM_SPEED = 0.0015;
      camRadius += e.deltaY * ZOOM_SPEED * camRadius;
      camRadius = Math.max(3.2, Math.min(7, camRadius));
      updateCamera();
    }, { passive: true });

    const clock = new THREE.Clock();
    let elapsed = 0;

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      elapsed += delta;

      if (mixer) mixer.update(delta);

      // –∞–º–ø–ª–∏—Ç—É–¥–∞ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è; –µ—Å–ª–∏ –Ω–∞ –∫–æ–ª–µ–Ω—è—Ö ‚Äî –º–µ–Ω—å—à–µ
      const moodNorm = (mood + 100) / 200; // 0..1
      const baseFactor = isKneeling ? 0.3 : 1.0;
      const bobAmp = baseFactor * (0.03 + 0.04 * moodNorm);
      const swayAmp = baseFactor * (0.12 + 0.08 * moodNorm);

      marik.position.y = Math.sin(elapsed * 2) * bobAmp;
      marik.rotation.y = Math.sin(elapsed * 0.5) * swayAmp;

      // –û—Ñ–∏—Å–Ω—ã–π —Ñ–æ–Ω: –ª—ë–≥–∫–æ–µ "–¥—ã—Ö–∞–Ω–∏–µ" —Å—Ü–µ–Ω—ã + –∫–∞—á–∞–Ω–∏–µ —Ä–∞—Å—Ç–µ–Ω–∏—è
      backgroundGroup.rotation.y = Math.sin(elapsed * 0.1) * 0.03;

      if (plant) {
        plant.rotation.z = Math.sin(elapsed * 1.2) * 0.05;
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  }
</script>
</body>
</html>
